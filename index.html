<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Для коханої ❤️</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            min-height: 100vh;
            background: #f5e6d3; /* кремовий фон */
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Segoe UI', Roboto, sans-serif;
        }
        canvas {
            display: block;
            width: 1000px;
            height: 700px;
            box-shadow: 0 20px 30px rgba(0,0,0,0.1);
            border-radius: 24px;
            background: #fdf8f2; /* кремовий фон канваса */
            cursor: none;
        }
    </style>
</head>
<body>
    <canvas id="heartCanvas" width="1000" height="700"></canvas>
    <script>
        (function() {
            const canvas = document.getElementById('heartCanvas');
            const ctx = canvas.getContext('2d');

            // ========== НАЛАШТУВАННЯ ==========
            const CREAM = '#fdf8f2';          // чистий кремовий фон
            const RED = '#e63946';              // червоний для квадрата/серця
            const BRUSH_SIZE = 4;                // піксель-квадрат 4x4
            const HEART_SCALE = 6;                // масштаб серця
            const HEART_CENTER_X = 500;            // новий центр (було 400)
            const HEART_CENTER_Y = 350;            // новий центр (було 300)

            // Тривалість фаз (мілісекунди)
            const DURATION_HEART = 8000;      // 8 сек на серце
            const DURATION_TEXT1 = 4000;       // 4 сек на перший напис
            const DURATION_TEXT2 = 4000;       // 4 сек на другий напис
            const DURATION_SHIMMER = 4000;     // 4 сек мерехтіння
            const DURATION_FIREWORK = 2000;     // 2 сек феєрверк

            // ========== ГЛОБАЛЬНІ ЗМІННІ ==========
            let heartPoints = [];
            let text1Points = [];
            let text2Points = [];

            let phase = 'heart';
            let phaseStartTime = performance.now();
            let fireworkParticles = [];

            // ========== ДОПОМІЖНІ ФУНКЦІЇ ==========
            function clearCanvas() {
                ctx.fillStyle = CREAM;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            function drawPixel(x, y, color) {
                ctx.fillStyle = color;
                ctx.fillRect(x, y, BRUSH_SIZE, BRUSH_SIZE);
            }

            // ========== ГЕНЕРАЦІЯ ТОЧОК СЕРЦЯ ==========
            function generateHeartPoints() {
                const points = [];
                const heartFn = (t) => {
                    const x = 16 * Math.pow(Math.sin(t), 3);
                    const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                    return { x, y };
                };

                const startT = 1.0; // початок з правої верхньої частини
                const endT = startT + 2 * Math.PI;
                const step = 0.025;

                for (let t = startT; t <= endT; t += step) {
                    const { x: rawX, y: rawY } = heartFn(t);
                    const screenX = Math.round(HEART_CENTER_X + HEART_SCALE * rawX);
                    const screenY = Math.round(HEART_CENTER_Y - HEART_SCALE * rawY);
                    if (screenX >= 0 && screenX < canvas.width && screenY >= 0 && screenY < canvas.height) {
                        points.push({ x: screenX, y: screenY });
                    }
                }
                return points;
            }

            // ========== ГЕНЕРАЦІЯ ТЕКСТОВИХ ПІКСЕЛІВ ==========
            function generateTextPixels(text, baseX, baseY, fontSize = 34) { // трохи зменшимо шрифт
                const offCanvas = document.createElement('canvas');
                const offCtx = offCanvas.getContext('2d');
                offCtx.font = `bold ${fontSize}px 'Segoe UI', 'Arial', sans-serif`;
                offCtx.textBaseline = 'top';

                const metrics = offCtx.measureText(text);
                const textWidth = Math.ceil(metrics.width);
                const textHeight = Math.ceil(fontSize * 1.3); // запас

                offCanvas.width = textWidth;
                offCanvas.height = textHeight;

                offCtx.clearRect(0, 0, textWidth, textHeight);
                offCtx.fillStyle = '#000000';
                offCtx.font = `bold ${fontSize}px 'Segoe UI', 'Arial', sans-serif`;
                offCtx.textBaseline = 'top';
                offCtx.fillText(text, 0, 0);

                const imageData = offCtx.getImageData(0, 0, textWidth, textHeight);
                const data = imageData.data;

                const points = [];
                for (let y = 0; y < textHeight; y++) {
                    for (let x = 0; x < textWidth; x++) {
                        const index = (y * textWidth + x) * 4 + 3;
                        if (data[index] > 0) {
                            const px = baseX + x * BRUSH_SIZE;
                            const py = baseY + y * BRUSH_SIZE;
                            if (px >= 0 && px < canvas.width && py >= 0 && py < canvas.height) {
                                points.push({ x: px, y: py });
                            }
                        }
                    }
                }
                return points;
            }

            // ========== ІНІЦІАЛІЗАЦІЯ ==========
            function initPoints() {
                heartPoints = generateHeartPoints();
                console.log(`Точок серця: ${heartPoints.length}`);

                // "МИШКІНСОНУ" зліва зверху (збільшили відступ, щоб точно влізло)
                const margin = 40;
                text1Points = generateTextPixels('МИШКІНСОНУ', margin, margin, 34);
                console.log(`Точок "МИШКІНСОНУ": ${text1Points.length}`);

                // "ВІД ЖАБАКА" справа знизу (обчислимо позицію)
                const tempPoints = generateTextPixels('ВІД ЖАБАКА', 0, 0, 34);
                if (tempPoints.length > 0) {
                    let maxX = 0, maxY = 0;
                    tempPoints.forEach(p => {
                        if (p.x > maxX) maxX = p.x;
                        if (p.y > maxY) maxY = p.y;
                    });
                    const rightPos = canvas.width - maxX - margin;
                    const bottomPos = canvas.height - maxY - margin;
                    text2Points = generateTextPixels('ВІД ЖАБАКА', rightPos, bottomPos, 34);
                } else {
                    text2Points = generateTextPixels('ВІД ЖАБАКА', 650, 550, 34);
                }
                console.log(`Точок "ВІД ЖАБАКА": ${text2Points.length}`);
            }

            // ========== ФЕЄРВЕРК ==========
            function spawnFirework() {
                fireworkParticles = [];
                const count = 200;
                for (let i = 0; i < count; i++) {
                    const angle = Math.random() * 2 * Math.PI;
                    const speed = 2 + Math.random() * 6;
                    const vx = Math.cos(angle) * speed;
                    const vy = Math.sin(angle) * speed;
                    fireworkParticles.push({
                        x: 500, y: 350, // центр (новий)
                        vx: vx,
                        vy: vy,
                        color: `hsl(${Math.random() * 360}, 90%, 60%)`,
                        life: 0.5 + Math.random() * 0.8,
                        size: 3 + Math.random() * 5
                    });
                }
            }

            function updateFirework(deltaSec) {
                for (let p of fireworkParticles) {
                    p.life -= deltaSec;
                    if (p.life > 0) {
                        p.x += p.vx * deltaSec * 30;
                        p.y += p.vy * deltaSec * 30;
                        p.vy += 20 * deltaSec;
                    }
                }
                fireworkParticles = fireworkParticles.filter(p => p.life > 0);
                return fireworkParticles.length > 0;
            }

            function drawFirework() {
                for (let p of fireworkParticles) {
                    ctx.fillStyle = p.color;
                    ctx.globalAlpha = Math.min(p.life, 1);
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, 2 * Math.PI);
                    ctx.fill();
                }
                ctx.globalAlpha = 1.0;
            }

            // ========== ЦИКЛ АНІМАЦІЇ ==========
            function animate(now) {
                const elapsed = now - phaseStartTime;
                clearCanvas();

                if (phase === 'heart') {
                    const progress = Math.min(1, elapsed / DURATION_HEART);
                    const index = Math.floor(progress * heartPoints.length);
                    for (let i = 0; i < index; i++) {
                        drawPixel(heartPoints[i].x, heartPoints[i].y, RED);
                    }
                    if (index >= heartPoints.length) {
                        phase = 'text1';
                        phaseStartTime = now;
                    }
                } 
                else if (phase === 'text1') {
                    heartPoints.forEach(p => drawPixel(p.x, p.y, RED));

                    const progress = Math.min(1, elapsed / DURATION_TEXT1);
                    const index = Math.floor(progress * text1Points.length);
                    for (let i = 0; i < index; i++) {
                        drawPixel(text1Points[i].x, text1Points[i].y, RED);
                    }
                    if (index >= text1Points.length) {
                        phase = 'text2';
                        phaseStartTime = now;
                    }
                }
                else if (phase === 'text2') {
                    heartPoints.forEach(p => drawPixel(p.x, p.y, RED));
                    text1Points.forEach(p => drawPixel(p.x, p.y, RED));

                    const progress = Math.min(1, elapsed / DURATION_TEXT2);
                    const index = Math.floor(progress * text2Points.length);
                    for (let i = 0; i < index; i++) {
                        drawPixel(text2Points[i].x, text2Points[i].y, RED);
                    }
                    if (index >= text2Points.length) {
                        phase = 'shimmer';
                        phaseStartTime = now;
                    }
                }
                else if (phase === 'shimmer') {
                    heartPoints.forEach(p => drawPixel(p.x, p.y, RED));

                    const shimmerColors = [RED, '#ffb347', '#4a90e2', '#9b59b6', '#2ecc71', '#f1c40f', '#e67e22'];
                    text1Points.forEach(p => drawPixel(p.x, p.y, shimmerColors[Math.floor(Math.random() * shimmerColors.length)]));
                    text2Points.forEach(p => drawPixel(p.x, p.y, shimmerColors[Math.floor(Math.random() * shimmerColors.length)]));

                    if (elapsed >= DURATION_SHIMMER) {
                        phase = 'firework';
                        phaseStartTime = now;
                        spawnFirework();
                    }
                }
                else if (phase === 'firework') {
                    if (window._lastFireworkTime) {
                        const delta = (now - window._lastFireworkTime) / 1000;
                        updateFirework(Math.min(0.05, delta));
                    }
                    window._lastFireworkTime = now;

                    drawFirework();

                    if (elapsed >= DURATION_FIREWORK || fireworkParticles.length === 0) {
                        phase = 'heart';
                        phaseStartTime = now;
                        window._lastFireworkTime = null;
                    }
                }

                requestAnimationFrame(animate);
            }

            // ========== СТАРТ ==========
            initPoints();
            phaseStartTime = performance.now();
            requestAnimationFrame(animate);
        })();
    </script>
</body>
</html>